---
layout: post
title: Using Machine Learning to Recommend Heroes for Dota 2 Matches
date: '2013-12-30T01:18:00-08:00'
tags:
- dota 2
- machine learning
- stanford
- cs229
- cs 229
- github
tumblr_url: https://kevintechnology.com/post/71621133663/using-machine-learning-to-recommend-heroes-for
---
<p>I took Stanford&rsquo;s machine learning class, CS 229, this past quarter. For my final project, I worked with <a href="http://www.linkedin.com/in/danieljamesperry" target="_blank">Daniel Perry</a> to apply a few different machine learning algorithms to the problem of recommending heroes for Dota 2 matches.<br/><br/><strong>TL;DR</strong>: We achieved about 70% accuracy for predicting match outcomes based on hero selection alone using logistic regression, and we made a small improvement on that result using K-nearest neighbors.<br/><br/><a href="https://github.com/kevincon/dotaml/blob/master/docs/final_report.pdf?raw=true" target="_blank">Download final report</a><br/><a href="https://github.com/kevincon/dotaml" target="_blank">Code on GitHub</a></p>
<p><img alt="image" src="https://78.media.tumblr.com/db7c70f58d83995251a8f8df44f57b0f/tumblr_inline_mym4o2xsr41qcrluu.jpg" title=""/></p>

<p><br/><strong>Introduction</strong><br/><br/>Dota 2, the sequel to a Warcraft III mod called Defense of the Ancients (DotA), is an online multiplayer computer game that has attracted professional players and the arrival of international tournaments. Each match consists of two teams of five players controlling &ldquo;heroes&rdquo; with an objective of destroying the opposing team&rsquo;s stronghold. There are 106 unique heroes in Dota 2 (circa December 2013).<br/><br/>Why work on a hero recommendation engine for Dota 2? A widely-believed conjecture is that the heroes chosen by each team drastically influences the outcome of the match. The positive and negative relationships between heroes can give one team an implicit advantage over the other team. Valve&rsquo;s annual Dota 2 tournament, <a href="http://wiki.teamliquid.net/dota2/The_International/2013#Prize_Pool" target="_blank">The International</a>, had a prize pool of over $2.8 million dollars in August 2013. With that much money on the line, professional teams recognize the importance of hero selection. Some matches take up to ten minutes for hero selection by both teams. <br/><br/>Professional players spend thousands of hours practicing the game, so they tend to gain an intuition for picking heroes. This &ldquo;gut instinct&rdquo; is not as accessible to more casual players, so we thought it would be interesting to explore how machine learning could help solve the problem of recommending heroes.<br/><br/><strong>Related Work</strong><br/><br/>In researching prior work, we discovered a web application called <a href="http://dota2cp.com" target="_blank">Dota 2 Counter-Pick</a> that uses machine learning to recommend heroes for Dota 2 matches. From the website&rsquo;s about page:<br/><br/><em>&ldquo;We model hero picking as a zero-sum-game and learn the game matrix by logistic regression. When suggesting picks and bans we assume that teams are mini-max agents that take turns picking one hero at a time.&rdquo;</em><br/><br/><em>&ldquo;Our growing database includes over 1 million matches from the high skill bracket where players did not disconnect or leave. For 63% of these matches, our method predicted the winning team correctly based on picks alone.&rdquo;</em><br/><br/>We were very inspired by the accuracy of Dota 2 Counter-Pick, and we set out to improve on their results.<br/><br/><strong>Data Collection</strong><br/><br/>We used the <a href="http://wiki.teamfortress.com/wiki/WebAPI#Dota_2" target="_blank">Steam Web API</a> for collecting data about public Dota 2 matches. We wrote a Python script (called <a href="https://github.com/kevincon/dotaml/blob/master/data_collection/dotabot2.py?source=cc" target="_blank">dotabot2.py</a> in the GitHub repository) and set it up on a cron job to record data from the 500 most recent public matches every 20 minutes. We only considered matches that satisfied the following requirements:</p>
<ol><li>The game mode is either all pick, single draft, all random, random draft, captain&rsquo;s draft, captain&rsquo;s mode, or least played. These game modes are the closest to the true vision of Dota 2, and every hero has the potential to show up in a match.</li>
<li>The skill level of the players is &ldquo;very-high,&rdquo; which corresponds to roughly the top 8% of players. We believe utilizing only very-high skill level matches allows us to best represent heroes at their full potential.</li>
<li>No players leave the match before the game is completed. Such matches do not capture how the absent players&rsquo; heroes affect the outcome of the match.</li>
</ol><p>We filtered our dataset on some of these requirements after running dotabot2.py, so that script&rsquo;s is_valid_match() function does not account for all three of these requirements.</p>
<p>The data for each match is structured as JSON and includes which heroes were chosen for each team, how those heroes performed over the course of the game, and which team ultimately won the game. We stored the JSON for each match in a MongoDB database during data collection.<br/><br/>We collected data for 56,691 matches between November 5, 2013 and December 7, 2013. We exported 90% of the matches from our database to form a training set of 51,022 matches. We exported the remaining 10% of our database to form a test set of 5,669 matches.<br/><br/><strong>Picking a Feature Vector</strong><br/><br/>Machine learning algorithms typically require an input query to be described as a vector of features. For our feature vector, we came up with the following scheme to describe which heroes were chosen by each team in a match:<br/><br/>In Dota 2 matches, one team is called the &ldquo;radiant&rdquo; and the other team is called the &ldquo;dire.&rdquo; These terms are roughly analogous to &ldquo;home&rdquo; and &ldquo;away,&rdquo; as they only determine the starting point of each team on the game world map, which is roughly symmetric.<br/><br/>There are 106 heroes in Dota 2 (circa December 2013), but the web API uses hero ID numbers that range from 1 to 108 (two hero IDs are not used), so for our algorithms we used a 216-element feature vector, <span class="pre">x,</span> such that:</p>
<p><img alt="image" src="https://78.media.tumblr.com/50c282dddd81ec4feb13e7b5748c7ab4/tumblr_inline_mym38931kq1qcrluu.png" title=""/></p>

<p>We also defined our label, y, to be:<br/><br/><img alt="image" src="https://78.media.tumblr.com/37207d3739e161aa2e6cb799e8f64381/tumblr_inline_mym38mXDW31qcrluu.png"/><br/><br/><strong>Making Predictions</strong><br/><br/>Since our dataset contains information about heroes on teams in specific radiant vs. dire configurations, simply running our algorithms on each match in our dataset using the feature vector described above does not fully utilize all of the data.<br/><br/>Instead, we make predictions using the following procedure. Given a match feature vector, which we call <em>radiant_query</em>:</p>
<ol><li>Run the algorithm on <em>radiant_query</em> to get <em>radiant_prob</em>, the probability that the radiant team in <em>radiant_query</em> wins the match.</li>
<li>Construct <em>dire_query </em>by swapping the radiant and dire teams in <em>radiant_query </em>so that the radiant team is now the bottom half of the feature vector and the dire team is now the top half of the feature vector.</li>
<li>Run the algorithm on <em>dire_query</em> to get <em>dire_prob</em>, the probability that the radiant team in <em>radiant_query</em> loses the match if it was actually the dire team instead.</li>
<li>Calculate the overall probability <em>overall_prob</em> as the average of <em>radiant_prob</em> and (1 - <em>dire_prob</em>).</li>
<li>Predict the outcome of the match specified by <em>radiant_query</em> as the radiant team winning if <em>overall_prob</em> &gt; 0.5 and as the dire team winning otherwise.</li>
</ol><p>This procedure accounts for matches in our dataset that might not have the team configuration of a given query in one direction (e.g. radiant vs. dire) but may have the configuration in the other direction (e.g. dire vs. radiant).</p>
<p><strong>Validating the Importance of Hero Selection Using Logistic Regression</strong><br/><br/>Logistic regression is a model that predicts a binary output using a weighted sum of predictor variables. We first trained a simple logistic regression model with an intercept term to predict the outcome of a match.<br/><br/>A plot of our learning curve for logistic regression is shown below. The test accuracy of our model asymptotically approaches 69.8% at about an 18,000 training set size, indicating that 18,000 matches is an optimal training set size for our logistic regression model.<br/><br/><img alt="image" src="https://78.media.tumblr.com/eeab885e9e10812dec892cea71c18c4e/tumblr_inline_mym1ryhFYy1qcrluu.png" title=""/></p>

<p>We believe that this logistic regression model shows that hero selection alone is an important indicator of the outcome of a Dota 2 match. However, since logistic regression is purely a weighted sum of our feature vector (which only indicates which heroes are on either team), logistic regression fails to capture the synergistic and antagonistic relationships between heroes.</p>
<p><strong>Predicting Match Outcome Using K-Nearest Neighbors</strong><br/><br/>K-nearest neighbors (KNN) is a non-parametric method for classification and regression that predicts objects&rsquo; class memberships based on the k-closest training examples in the feature space.<br/><br/>We chose to implement KNN in order to better model the relationships between heroes instead of simply taking into account wins when a hero is present.<br/><br/>At a high level, we continue to focus on wins and the hero composition of teams, however with KNN, we have an avenue to weigh matches according to how similar they are to a query match we are interested in. For example, if we are interested in projecting who will win a specific five on five matchup (our query match), a match with nine of the heroes from the query match present will give us more information on who will win the query match than a match with only one hero from the query match present.<br/><br/>We used a custom weight and distance function and chose to utilize all training examples as &ldquo;nearest neighbors.&rdquo; Our polynomial weight function described below aggressively gives less weight to dissimilar training examples:<br/><img alt="image" src="https://78.media.tumblr.com/11f59b69babe80d2b4196e1bf5f58d75/tumblr_inline_mym3crF0BJ1qcrluu.png" title=""/><br/>Here, x^(i) represents the feature vector for training match i and is compared by the logical AND operator to query vector q. Index j represents the hero ID index of each respective vector. NUM_IN_QUERY represents the number of heroes present in the query vector. For example, NUM_IN_QUERY is 10 if the query contains all 5 heroes for each team.<br/><br/>The function is normalized to be between 0 and 1, and it gives more weight to matches that more closely resemble the query match. To do this, the function compares the query match vector to the training match vector and counts every instance where a hero is present in both vectors.<br/><br/>A larger d parameter will result in similar matches getting much more weight than dissimilar matches. Alternatively, a low d, for example d = 1, will result in each match being weighted solely by how many heroes in common the match has with the query match. Stated another way, a high d will choose to put more emphasis on the synergistic and antagonistic relationships between heroes, while a lower d will put more emphasis on the independent ability of a hero.<br/><br/>To choose the optimal d dimension parameter described above, we used k-fold cross validation with k=2 on 20,000 matches from our training set and varied d across otherwise identical KNN models. <br/><br/>Since KNN must compare the query match to every match in the training set and compute weights and probabilities, this process was quite slow and took about ten hours. Due to time constraints, using more folds or more matches would have taken too long to finish.<br/><br/>A graph of the accuracies achieved when varying the weight dimension for a KNN model trained on our training set and evaluated on our test set is shown below. We found the optimal weight dimension to be d=4, which achieved a mean accuracy of 67.43% during the k-fold cross validation.</p>
<p><img alt="image" src="https://78.media.tumblr.com/c80b95f3ce8d2e44b1631aad52810037/tumblr_inline_mym2drbqEf1qcrluu.png" title=""/></p>

<p><br/>A plot of our learning curve for KNN is shown below. The test accuracy of our model monotonically increases with training set size up to nearly 70% for around 50,000 training matches. Because we do not see the learning curve level off, this may imply that more data could further improve our accuracy.<br/><img alt="image" src="https://78.media.tumblr.com/c6cef68a6d602af2ef6e1ae88d98f6a5/tumblr_inline_mym2dgBMRL1qcrluu.png" title=""/></p>

<p><strong>Recommending Heroes Based on Predicted Match Outcome</strong><br/><br/>We recommend heroes for a team using a greedy search that considers every possible hero that could be added to the team and ranks the candidates by probability of the team winning against the opposing team if the candidate was added to the team.<br/><br/>Our recommendation engine is modular so that either of our algorithms could be used to recommend heroes. Given the ID numbers of the heroes on both teams, the recommendation engine proceeds as follows:<br/><br/>1. Create a feature vector for the match.<br/>2. Create a set of new feature vectors, each with a different candidate hero added to the original feature vector.<br/>3. Run an algorithm to compute the probability of victory with each feature vector from step 2, averaging the probabilities of the team winning in both radiant and dire configurations as described earlier.<br/>4. Sort the candidates by probability of victory to give ranked recommendations.<br/><br/><strong>Future Work</strong><br/><br/>Despite the high accuracy of our K-nearest neighbor model, the performance was quite slow. The five data points we used in our learning curve took about four hours total to calculate, and the k-fold cross validation used to find the optimal weight dimension took over 12 hours.<br/><br/>We believe that the performance of our K-nearest neighbor model could be improved in a number of ways. First, the binary feature vector used could be stored as an integer in binary representation to improve memory usage. Second, the calculation of weighted distances could be parallelized across multiple CPU cores. Third, a GPU could be utilized to vectorize the weighted distance function calculations.<br/><br/>Although the version of the game did not change during the time we collected match data, a new patch is released for Dota 2 every few months that dramatically changes the balance of the game. Therefore, we believe that a sliding window of match history data that resets when a new patch is released could help maintain data relevancy. For this reason, it would be useful to find if there is a training match size for which performance levels off so that we could collect only as much data as is needed.<br/><br/>Finally, we could experiement with a different search algorithm for our recommendation engine such as A* which would account for the opposing team picking heroes that could counter our initial recommendations. However, due to time constraints we were not able to implement A* search for our recommendation engine.<br/><br/>Ultimately, we believe there are many promising directions which future explorations in this area could take.</p>
<p><strong>Conclusion</strong><br/><br/>We don&rsquo;t claim to be experts on Dota 2 or machine learning, but we are encouraged by our results that machine learning could be an effective tool in recommending heroes for Dota 2 matches. Feel free to contribute to the project on Github and contact us with any questions.</p>
